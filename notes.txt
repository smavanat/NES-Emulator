
| Microinstruction            | Description                                     |
| --------------------------- | ----------------------------------------------- |
| `fetch_opcode`              | Fetch instruction byte from PC and increment PC |
| `fetch_operand_zp`          | Fetch 8-bit operand from PC and increment PC    |
| `fetch_operand_abs_low`     | Fetch low byte of 16-bit address                |
| `fetch_operand_abs_high`    | Fetch high byte of 16-bit address               |
| `read_memory(addr)`         | Read from memory                                |
| `write_memory(addr, value)` | Write to memory                                 |
| `read_zp(addr)`             | Shortcut for reading zero page                  |
| `write_zp(addr, value)`     | Shortcut for writing zero page                  |


| Microinstruction     | Description                                      |
| -------------------- | ------------------------------------------------ |
| `addr_zp()`          | Compute zero page address                        |
| `addr_zp_x()`        | Compute zero page address + X                    |
| `addr_zp_y()`        | Compute zero page address + Y                    |
| `addr_abs()`         | Use 16-bit operand as address                    |
| `addr_abs_x()`       | Add X to absolute address (may take extra cycle) |
| `addr_abs_y()`       | Add Y to absolute address (may take extra cycle) |
| `addr_indirect()`    | For JMP (\$xxxx), indirect fetch                 |
| `addr_indirect_y()`  | (ZP),Y with optional page crossing               |
| `addr_indirect_x()`  | (ZP,X) pre-indexed indirect                      |
| `check_page_cross()` | If page boundary is crossed, perform dummy read  |


| Microinstruction     | Description                     |
| -------------------- | ------------------------------- |
| `alu_add(value)`     | Add to accumulator (ADC)        |
| `alu_sub(value)`     | Subtract from accumulator (SBC) |
| `alu_and(value)`     | Bitwise AND with accumulator    |
| `alu_ora(value)`     | Bitwise OR with accumulator     |
| `alu_eor(value)`     | Bitwise XOR with accumulator    |
| `alu_cmp(value)`     | Compare (A - value), set flags  |
| `alu_inc(value)`     | Increment memory                |
| `alu_dec(value)`     | Decrement memory                |
| `shift_left(value)`  | ASL or ROL                      |
| `shift_right(value)` | LSR or ROR                      |
| `test_bit(value)`    | BIT instruction logic           |


| Microinstruction         | Description                                           |
| ------------------------ | ----------------------------------------------------- |
| `load_a(value)`          | Load into A                                           |
| `load_x(value)`          | Load into X                                           |
| `load_y(value)`          | Load into Y                                           |
| `store_a(addr)`          | Store A to addr                                       |
| `store_x(addr)`          | Store X to addr                                       |
| `store_y(addr)`          | Store Y to addr                                       |
| `set_flag(flag)`         | Set a specific status bit                             |
| `clear_flag(flag)`       | Clear a status bit                                    |
| `update_nz_flags(value)` | Update N (negative) and Z (zero) flags based on value |


| Microinstruction             | Description                             |
| ---------------------------- | --------------------------------------- |
| `fetch_relative_offset()`    | Fetch signed offset for branch          |
| `branch_if(flag, condition)` | Conditional PC change                   |
| `check_branch_page_cross()`  | If branch crosses page, add extra cycle |
| `perform_branch()`           | Actually update PC with offset          |


| Microinstruction | Description                      |
| ---------------- | -------------------------------- |
| `push(value)`    | Write to stack and decrement SP  |
| `pop()`          | Increment SP and read from stack |
| `push_pc_high()` | Push high byte of PC             |
| `push_pc_low()`  | Push low byte of PC              |
| `push_status()`  | Push status flags                |
| `pull_pc_low()`  | Pull low byte of PC              |
| `pull_pc_high()` | Pull high byte of PC             |
| `pull_status()`  | Pull flags                       |


| Microinstruction   | Description                                                    |
| ------------------ | -------------------------------------------------------------- |
| `dummy_read(addr)` | Read memory without using result (for timing or page crossing) |
| `idle_cycle()`     | Do nothing but consume 1 cycle                                 |
| `dma_wait()`       | For OAM DMA in NES â€” block CPU for 513 or 514 cycles           |
